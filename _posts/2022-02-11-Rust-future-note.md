---
layout: post
title: Notes - Rust Future
subtitle: å­¦ä¹  async Rust çš„ç¬”è®°ï¼ˆå¯è¯»æ€§å·®ï¼‰
tags: [Rust]
comments: true
---

# 1. Basics

## 1.1 Why futures?

å¯¹äºå¹¶å‘ä»»åŠ¡ï¼ŒOS ä¸€èˆ¬é‡‡ç”¨ Preemptive Multitasking çš„æ–¹å¼ï¼Œå³æ‰€æœ‰çº¿ç¨‹éƒ½ç”±ç³»ç»Ÿè¢«åŠ¨æš‚åœ/ç»ˆæ­¢ï¼Œæ§åˆ¶æƒæŒæ¡åœ¨ç³»ç»Ÿæ‰‹é‡Œï¼›è€Œ Cooperative Multitaskingï¼Œå³ä»»åŠ¡ä¸»åŠ¨è®©å‡ºæ§åˆ¶æƒï¼Œåˆ™ä¸€èˆ¬é€‚ç”¨äºç»†ç²’åº¦çš„å¹¶è¡Œä»»åŠ¡ï¼Œç”±ç¼–ç¨‹è¯­è¨€æä¾›ã€‚Futures æ˜¯ Rust ä¸ºè½»é‡çº§çš„å¹¶å‘ä»»åŠ¡æä¾›äº†ä¸€ç§è§£å†³æ–¹æ¡ˆï¼Œå…¶ä¸»è¦çš„ä½¿ç”¨åœºæ™¯æ˜¯ï¼Œå½“ä¸€ä¸ªèµ„æºè¦æ±‚æœªæ»¡è¶³æ—¶ï¼Œæ”¾å¼ƒå¯¹çº¿ç¨‹çš„æ§åˆ¶æƒï¼Œç­‰åˆ°èµ„æºæ»¡è¶³æ—¶å†è°ƒåº¦å›å»ã€‚ç›¸æ¯”äºå¤šçº¿ç¨‹çš„å¹¶å‘æ–¹å¼ï¼Œåœ¨æ€§èƒ½ï¼ˆæ²¡æœ‰ context switchingï¼‰ä¸Šå’Œå†…å­˜å ç”¨ï¼ˆçº¿ç¨‹ä¸Šçš„æ‰€æœ‰ä»»åŠ¡å¯ä»¥å…±äº«ä¸€ä¸ªæ ˆï¼‰ä¸Šéƒ½æœ‰æ›´å¥½çš„è¡¨ç°ã€‚

Futures çš„ç«äº‰è€…ä»¬ï¼š
1. OS threadsï¼šæ ˆè¾ƒå¤§ï¼Œç³»ç»Ÿè°ƒç”¨è¾ƒå¤šï¼Œçº¿ç¨‹è°ƒåº¦ç”± OS è´Ÿè´£ä¸å¤ªè‡ªç”±ã€‚
2. Greenthreadsï¼šç›¸æ¯”äº OS threads åˆ‡æ¢å¼€é”€å°‘äº†å¾ˆå¤šï¼Œä½†æ˜¯æ¯ä¸ªçº¿ç¨‹ä¸€ä¸ªæ ˆçš„æ–¹å¼ä»ç„¶å¯¼è‡´æ‰©å±•æ€§ä¸å¥½ã€‚
3. Callbacksï¼šä¸ºæ¯ä¸ªä»»åŠ¡æ³¨å†Œä¸€ä¸ªå›è°ƒå‡½æ•°ï¼ˆæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼‰ï¼Œä½†æ˜¯ç»™ç¼–ç¨‹å¸¦æ¥å¾ˆå¤§çš„å›°éš¾ -- å›è°ƒåœ°ç‹±ï¼
4. Promisesï¼šJS çš„ Promise å’Œ Rust çš„ Future å·®ä¸å¤šï¼Œé™¤äº†ä¸€ä¸ªæ˜¯ eagerly evaluated å¦ä¸€ä¸ªæ˜¯ lazily evaluatedï¼Œæ­¤å¤–å®ƒçš„ç¼–ç¨‹è¿‡ç¨‹ä¸­ `and_then` chaining ç»™è·¨ step çš„æ‰€æœ‰æƒè½¬ç§»å¸¦æ¥ä¸€å®šçš„å›°éš¾ï¼ˆä½†æ˜¯ async/await åˆ™å¯ä»¥ç”¨åŒæ­¥çš„é£æ ¼å†™ä»£ç ï¼‰ã€‚

æ‰€ä»¥è¯´ï¼Œå¯¹äºæ•°é‡è¾ƒå¤šçš„è½»é‡çº§ä»»åŠ¡ï¼ŒFuture æœºåˆ¶æ˜¯å¾ˆé€‚åˆçš„ã€‚

## 1.2 How does a future work?

Future ä¹‹é—´çš„å…³ç³»å¯ä»¥è¢«ç†è§£æˆä¸€æ£µæ ‘ï¼Œæ‰§è¡Œé¡ºåºåˆ™ç±»ä¼¼æ ‘çš„éå†ã€‚Futures ä¸»è¦åˆ†ä¸ºä¸¤ç§ï¼Œä¸€ç§æ˜¯ leaf futuresï¼Œå®Œå…¨ä¾èµ–å¤–éƒ¨èµ„æºï¼Œä¾‹å¦‚ä¸€ä¸ª socketã€æˆ–è€…è®¡æ—¶å™¨äº‹ä»¶ï¼Œä¸€ç§æ˜¯ non-leaf futuresï¼Œå®ƒä»¬ await è®¸å¤šå­ future çš„å®Œæˆã€‚åœ¨å¾ˆå¤šè°ƒåº¦å™¨å®ç°ä¸­ï¼ŒFuture æ ‘æ˜¯è°ƒåº¦çš„åŸºæœ¬å•ä½ã€‚

### Roles

- `Executor`: more like a scheduler which manages `Future`s in queues and polls them.
  In some libs, top-level Futures are called `Task`s, which are placed in READY/WAITING queue.
- `Reactor`: keeps an eye on the leaf futures and wakes the `Waker` which notifies the `Executor` to do some scheduling.
  `Waker`: TheÂ `Waker` struct is held by resources and is used to signal that a task isÂ *runnable* and be pushed into the scheduler's run queue.
- `Future`: state machine advanced by `poll`s.
  The **state machine** must keep track of the current state internally, i.e. the required variables. An `enum` variant is generated by the compiler, each field of which represents a state with variables attached. In the `poll` function, the state of `self` is matched. And in each match arm, its child future is polled, and if a `Ready` is returned, pick the variables for the next state and then assign `self` with a new `enum` field.


### ä¸€ä¸ª Future æ‰§è¡Œçš„ timeline

```rust
let non_leaf_fut = async {
    // A
    let leaf_fut = Reactor::new_io();
    leaf_fut.await
    // B
};
runtime.block_on(non_leaf_fut)
```

ä»¥ä¸Šæ˜¯ä¸€ä¸ª non-leaf Future è°ƒç”¨ä¸€ä¸ª leaf Future çš„ä¾‹å­ï¼Œæ—¶é—´é¡ºåºä¸Šå‘ç”Ÿçš„äº‹æƒ…å¤§æ¦‚æ˜¯è¿™æ ·ï¼š

| User / External incidents | Runtime |
| --- | --- |
| Create a Future which is compiled to a state machine. |  |
| Call block_on to this Future. | The Future is passed to the Executor and a Waker is created whose reference is passes to the Reactor later. |
|  | The Executor polls this Waker, and the code block A will be ran. |
| await the leaf future. | The Executor polls the leaf futureâ€™s Waker and gets a Poll::Pending, the Executor then puts the non_leaf_future in the WAITING queue and picks another task (i.e. top-level future) from the READY queue. |
| The I/O event is ready. | The Reactor is notified that an event is ready and then calls Waker::wake() which puts the future in the READY queue and notifies the Executor. |
|  | The Executor picks the Future from the READY queue and then polls it, this time a Poll::Ready(output) is returned. The state machine advances one more step, code block B in ran. |

{: .box-note}
**ğŸ’¡ Why not let the `Executor` to do the waking job?**\\
By having a wake up mechanism that isÂ *not*Â tied to the thing that executes the future, runtime-implementors can come up with interesting new wake-up mechanisms.\\
An example of this can be spawning a thread to do some work that eventually notifies the future, completely independent of the current runtime.\\
Without a waker, the executor would be theÂ *only*Â way to notify a running task, whereas with the waker, we get a loose coupling where it's easy to extend the ecosystem with new leaf-level tasks.

æ‰§è¡Œå™¨æ˜¯ç”¨æ¥æ‰§è¡Œ task çš„ï¼Œæ¯ä¸ªçŠ¶æ€æœºåˆ™äº‹å®ä¸Šæ˜¯ç”±å­ future é©±åŠ¨çš„ï¼Œå½’æ ¹ç»“åº•æ•´ä¸ªçŠ¶æ€æœºæ˜¯ç”±å¶å­ future é©±åŠ¨çš„ã€‚

å½“ä¸€ä¸ªå¶å­ future å®Œæˆæ—¶ï¼Œæˆ‘ä»¬å¦‚ä½•é€šçŸ¥æ‰§è¡Œå™¨ï¼Œè¿›è€Œè®©è¿™ä¸ªå¶å­ future çš„é¡¶å±‚ task è¢« wake up å‘¢ï¼Ÿç”¨æˆ·æ€ç¨‹åºå¾—çŸ¥ä¸€ä¸ªå¤–éƒ¨äº‹ä»¶è¢«å®Œæˆè¿™ä»¶äº‹æƒ…ä¸€èˆ¬ç”±å¤–éƒ¨é©±åŠ¨çš„å®ç°æä¾›ã€‚é€šè¿‡å°† Executor å’Œ Reactor è§£è€¦åˆï¼Œåœ¨â€œä»ç”¨æˆ·æ€ç¨‹åºå¾—åˆ°å¤–éƒ¨äº‹ä»¶ï¼Œåˆ°æ‰§è¡Œå™¨å» poll å¯¹åº”çš„ taskâ€è¿™ä¸€è¿‡ç¨‹ä¸­ï¼Œè¿è¡Œæ—¶åº“è¢«ç»™äºˆäº†æ›´å¤§çš„è‡ªç”±ã€‚è€Œ Reactor é€šçŸ¥ Executor è¿™ä¸€è¿‡ç¨‹ï¼Œåˆ™æ˜¯é€šè¿‡ Waker æ¥å®ç°çš„ã€‚

## 1.3 Implementation details

### Pinning

Future éœ€è¦è¢«æ ‡è®°ä¸º `Pin`ï¼Œè¿™æœ¬è´¨ä¸Šå› ä¸ºæ˜¯å®ƒæ˜¯å› ä¸ºä¸€ä¸ªè‡ªå¼•ç”¨ç»“æ„ä½“ï¼Œä¸å¯ä»¥æš´éœ² `&mut self` ä»¥è‡³äºè¢« moveã€‚Future æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæšä¸¾ç»“æ„ï¼Œæ¯ç§æšä¸¾ç±»å‹æ˜¯ä¸€ä¸ªçŠ¶æ€ï¼Œå…¶ä¸­å­˜å‚¨äº†å½“å‰æœ‰çš„å˜é‡ã€‚æœ‰çš„æ—¶å€™è¿™äº›å˜é‡æ˜¯å¦ä¸€äº›å˜é‡çš„å¼•ç”¨ï¼Œå³ Future ä¸­ä¸€äº› field æŒ‡å‘å¦ä¸€äº› fieldï¼Œè¿™å°±å¯¼è‡´ Future å˜æˆäº†ä¸€ä¸ªè‡ªå¼•ç”¨ç»“æ„ä½“ (self-referential struct)ã€‚


### Waker and Context

å¯¹äºä»€ä¹ˆæ—¶å€™è¢« poll ç„¶åçŠ¶æ€æœºæ¨è¿›è¿™ä»¶äº‹ï¼Œnon-leaf futures æ˜¯ç”±å®ƒçš„å­ future é©±åŠ¨çš„ï¼Œè€Œ leaf future åˆ™éœ€è¦å€ŸåŠ© `Waker` çš„å¸®åŠ©æ¥é€šçŸ¥ `Executor` è¿›è¡Œè°ƒåº¦ã€‚

åœ¨ `Future` trait çš„ `poll` æ–¹æ³•ä¸­ï¼Œæœ‰ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ª `Context`ï¼Œå®ƒå¯ä»¥ç†è§£ä¸ºä¸€ä¸ª `Waker` çš„ wrapperï¼Œä¸ºäº†ä»¥åçš„è¿­ä»£è€Œè®¾è®¡ï¼Œå¯ä»¥æ”¾ä¸€äº› task-local storage æˆ–è€… debugging hooks ç­‰ç­‰ã€‚

è°ƒç”¨ `Waker::wake()` æ¶‰åŠè¿è¡Œæ—¶å¤šæ€ï¼Œä¸€ä¸ª `&dyn Trait` æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªèƒ–æŒ‡é’ˆï¼Œå‰ 8 ä¸ªå­—èŠ‚æŒ‡å‘ trait objectï¼Œå 8 ä¸ªå­—èŠ‚æŒ‡å‘ä¸€ä¸ª vtableï¼Œè¿™ä¸ª vtable å±äºä¸€ä¸ª Trait implementationï¼Œå­˜äº†ä¸€äº› `Drop` å‡½æ•°çš„æŒ‡é’ˆã€trait function çš„æŒ‡é’ˆã€æ•°æ®å¤§å°ç­‰ç­‰ã€‚


## Reference

- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)
- [Async/Await](https://os.phil-opp.com/async-await/)

# 2. More Facts About Async

## 2.1 The designs of `async_trait`

å¤è¯»è¿™ç¯‡æ–‡ç« ï¼š
[Baby Steps - why async fn in traits are hard](http://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/)


### About `async_trait`

[GitHub - dtolnay/async-trait: Type erasure for async trait methods](https://github.com/dtolnay/async-trait)

ä¸€ä¸ªè¿‡ç¨‹å®ï¼Œç”±äºå¥‡æ€ªçš„åŸå› ï¼Œtrait ä¸­çš„æ–¹æ³•ä¸å¯ä»¥æ˜¯ async çš„ï¼Œå› ä¸º async fn å®é™…ä¸Šæ˜¯ä¸€ç§è¿”å›å€¼ä¸º `impl Future<...>` çš„å‡½æ•°ï¼Œä½†æ˜¯ trait ä¸å…è®¸å®šä¹‰è¿”å›å€¼ä¸º `impl Trait` çš„æ–¹æ³•ã€‚å› æ­¤ async trait å®é™…å°† trait ä¸­çš„ async fn ç¼–è¯‘ä¸ºæ™®é€šçš„å‡½æ•°ï¼Œå…¶è¿”å›å€¼æ˜¯ `Pin<Box<'_ + dyn Future<...> + Send>>` ï¼ˆä¸ä¸€å®šæ˜¯ `Send`ï¼Œå¯ä»¥æŠŠå®ƒå…³æ‰ï¼‰ã€‚

è¿™ç¯‡åšå®¢è®²äº†è®¾è®¡ `async_trait` æ—¶ä¸ºä»€ä¹ˆé‡‡ç”¨äº†è¿è¡Œæ—¶å¼€é”€æ›´å¤§çš„ `Pin<Box<dyn '_ + Future<...>>>` çš„å½¢å¼ã€‚


### Why not `impl Future`?

è¿™ä¸ªç­”æ¡ˆä¹Ÿå¯ä»¥è§£ç­”â€œä¸ºä»€ä¹ˆ trait ä¸­ä¸å¯ä»¥æœ‰ async fnâ€ï¼Œå› ä¸º async fn æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªå‡½æ•°ä½“ä¸º async blockã€è¿”å›å€¼ä¸º `impl Future<...>` çš„å‡½æ•°ã€‚

{: .box-note}
**ğŸ’¡ impl Trait v.s. dyn Trait**\\
Rust éœ€è¦æŸç§æœºåˆ¶æ¥ç¡®å®šæŸä¸ª Trait å…·ä½“æ˜¯å“ªä¸ªå®ç°ã€‚impl å…³é”®å­—å°±æ˜¯è¦æ±‚åœ¨ç¼–è¯‘çš„æ—¶å€™ç¡®å®šå®ç°ï¼Œç§°ä¸º static dispatchingï¼Œå…¶å®è´¨æ˜¯åœ¨ç¼–è¯‘çš„æ—¶å€™æ¶ˆé™¤æ³›å‹ï¼Œå˜æˆç¡®å®šç±»å‹çš„ä»£ç ï¼›è€Œ dyn åˆ™æ˜¯åœ¨è¿è¡Œæ—¶ç¡®å®šå®ç°ï¼Œç±»ä¼¼äº C++ é€šè¿‡ vtable æ¥è§£å†³ï¼Œä¹Ÿä¼šå¸¦æ¥ä¸€äº›è¿è¡Œæ—¶çš„æ€§èƒ½å¼€é”€ã€‚

Trait æ–¹æ³•çš„è¿”å›å€¼ä¸å¯ä»¥æ˜¯ `impl Trait`ï¼Œå› ä¸º Rust è¦æ±‚å‡½æ•°çš„è¿”å›å€¼æ˜¯å·²çŸ¥å¤§å°ã€‚å¯¹äºæ™®é€šçš„å‡½æ•°ï¼Œå¦‚æœè¿”å›å€¼æ˜¯ `impl Future`ï¼Œä¼šè¦æ±‚ç¼–è¯‘æœŸé—´çŸ¥é“è¿™ä¸ª Future å®ç°å…·ä½“æ˜¯ä»€ä¹ˆï¼Œæ™®é€šçš„å‡½æ•°è‡ªç„¶å¯ä»¥å®Œæˆè¿™ä¸€ç‚¹ã€‚å¯¹äº trait ä¸­çš„å‡½æ•°ï¼Œè¿™ä¸€ç‚¹åªèƒ½åœ¨å®ä¾‹åŒ–è¿™ä¸ª trait æ—¶æ‰èƒ½å¾—çŸ¥ã€‚

ä¸€ç§è¡Œä¸é€šçš„è§£å†³åŠæ³•æ˜¯åœ¨ç¼–è¯‘æ—¶å°† trait å˜ä¸ºä¸€ä¸ªå…·æœ‰ generic associated type çš„ traitï¼Œè¯¥å…³è”ç±»å‹å°±æ˜¯é‚£ä¸ªè¢«è¿”å›çš„ Futureã€‚è¿™æ ·ç¡®å®šè¿™ä¸ª Future çš„å…·ä½“å®ç°çš„å·¥ä½œè¢«äº¤ç»™äº† trait å®ç°è€…ã€‚ï¼ˆä¸ºä»€ä¹ˆæ˜¯ GAT è€Œä¸æ˜¯æ™®é€šçš„å…³è”ç±»å‹ï¼Ÿå› ä¸º async fn ä¼šæ•è·å®ƒä»¬æ‰€æ•è·çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œæ¯•ç«Ÿå¾ˆå¤š async fn å¸¦æœ‰ &self å‚æ•°...ï¼‰

P.S. ä»¥ä¸Šéƒ½æ˜¯å‡è®¾ï¼Œä¸è¿‡è¿™ä¸ªå‡è®¾ä¸­çš„ç¼–è¯‘å™¨æŠŠ `impl Future` å˜æˆæ³›å‹å‚æ•°æ˜¯ä¸æ˜¯æ›´åˆç†ä¸€äº›ï¼Ÿ

GAT çš„åŠ å…¥ä½¿å¾—å®ç°è¿™ä¸ª trait å˜å¾—æ›´éº»çƒ¦ä¸€äº›ï¼š

- ç¼–è¯‘å™¨ä¼šä¸ºè¿™ä¸ª GAT ç”Ÿæˆä¸€ä¸ªåå­—ï¼Œä½¿ç”¨è€…åœ¨ spawn è¿™ä¸ª future ç­‰ç”¨é€”æ—¶éœ€è¦å£°æ˜è¿™ä¸ª GAT ä¸º `Send`ï¼Œç„¶è€Œ GAT çš„åå­—æ˜¯ç¼–è¯‘å™¨å–çš„ï¼Œç»™ä¸ç†Ÿæ‚‰ç¼–è¯‘å™¨å†…éƒ¨ç»†èŠ‚çš„ç”¨æˆ·å¸¦æ¥å¾ˆå¤§éº»çƒ¦ã€‚
- è‹¥è¿™ä¸ª trait æœ‰å¤šä¸ªæ–¹æ³•è¿”å›å¤šä¸ª Futureï¼Œå†åŠ ä¸Šç”¨æˆ·è‡ªå·±çš„æ³›å‹å‚æ•°ï¼Œåœ¨ä½¿ç”¨æ—¶ç”¨æˆ·éœ€è¦è‡ªå·±æ ‡æ³¨çš„ trait bounds å°†ä¼šéå¸¸ææ€–ã€‚


## 2.2 The designs of `futures`

From Aron Turonâ€™s blogs:
- [Zero-cost futures in Rust](https://aturon.github.io/blog/2016/08/11/futures/)
- [Designing futures for Rust](https://aturon.github.io/blog/2016/09/07/futures-design/)


### The goals of futures crate

Whats futures solve: tracking a lot of asynchronous tasks and dispatching those to the right callbacks. (When an async event arrives, only one dynamic dispatch is required.)

**Aims:**
- Robust: error handling, thread-safety, etc.
- Ergonimic: making writing async codes as easy as synchronous code â†’ leverage Rustâ€™s traits and closures.
- Zero-cost: equivalent or better than a hand-driven state machine. **demand-driven** rather than callback-oriented, that is, composing the futures together without creating intermediate callbacks.

**Asynchrony**: you get aÂ *future*Â right away, without blocking, even though theÂ *value*Â the future represents will become ready only at some unknown time in theâ€¦ future.

{: .box-note}
**ğŸ’¡ Rustâ€™s traits â€” without heap allocation and dynamic dispatch**\\
Rust trait æ˜¯ä¸€ç§ç¼–è¯‘æ—¶å¤šæ€ã€‚å½“æˆ‘ä»¬è°ƒç”¨ä¸€ä¸ª trait å‡½æ•°æ—¶ï¼Œå®é™…ä¸Šç¡®å®šå®ç° trait çš„å…·ä½“ç±»å‹æ˜¯åœ¨ç¼–è¯‘æœŸé—´å®Œæˆçš„ï¼Œä¾‹å¦‚ä¸º `i32` å’Œ `i64` å®ç°äº† `hash()` å‡½æ•°ï¼Œç¼–è¯‘å™¨ä¼šå®ç° `_hash_i32()` å’Œ `_hash_i64()` ä¸¤ä¸ªå‡½æ•°ï¼Œç¼–è¯‘æœŸé—´å°†å¯¹åº”çš„ `hash()` è°ƒç”¨æ›¿æ¢ä¸º `_hash_i32()` æˆ–è€… `_hash_i64()`ã€‚\\
æ‰€ä»¥ç¡®å®šåˆ°åº•æ˜¯å“ªç§ `impl Future` å¹¶ä¸”å»è°ƒç”¨å¯¹åº”çš„ `poll` å®é™…ä¸Šæ˜¯åœ¨ç¼–è¯‘æœŸé—´åšçš„ã€‚


### How to achieve zero-cost?

æ­¤å¤„è€ƒå¯Ÿäº†å‡ ç§å®ç°æ€è·¯çš„æƒè¡¡ï¼š
- State machines or callbacks?
- Static dispatch or dynamic dispatch?

Rust å‡é€‰æ‹©äº†å‰è€…ï¼Œä¸‹é¢çš„å†…å®¹å°†è§£é‡Šå‰è€…ä¸ºä»€ä¹ˆæ˜¯ç›¸æ¯”äºåè€…æ€§èƒ½æ›´é«˜çš„é€‰æ‹©ã€‚

#### State machines V.S. callbacks:

åˆ†åˆ«åœ°å¯¹åº”äº†ä¸¤ç§æ€è·¯ï¼šdemand-driven V.S. completion-basedï¼Œå‰è€…è¢« poll æ¨åŠ¨çŠ¶æ€æœºï¼Œåè€…åˆ™ä¸€èˆ¬æ˜¯æ³¨å†Œå®Œæˆæ—¶çš„å›è°ƒã€‚

**Q1. What does a completion-based future look like?**

ä¸€ä¸ªç±»ä¼¼äºå›è°ƒçš„ Future trait å¤§æ¦‚æä¾›äº†ä¸€ä¸ªæ³¨å†Œå›è°ƒçš„æ¥å£ï¼Œå³å°†ä¸€ä¸ª FnOnce ä½œä¸ºå‚æ•°ã€‚ç¼ºç‚¹åœ¨äºéœ€è¦åå¤åœ°åˆ†é…å†…å­˜ä»¥åŠåŠ¨æ€åˆ†å‘ã€‚

åœ¨ join çš„åœºæ™¯ä¸‹ï¼Œç”¨æˆ·å°†ä¸¤ä¸ª future äº¤ç»™ join å¹¶ä¸”è‡ªå·±å®ç°äº†å›è°ƒï¼Œjoin ä¹Ÿè¿”å›ä¸€ä¸ª futureï¼Œç°åœ¨ join çš„å®ç°è€…éœ€è¦å®ç°è¿™ä¸ªå›è°ƒï¼Œè¿™ä¸ªå›è°ƒéœ€è¦å¯ä»¥è¢«ä¸¤ä¸ª future çš„ä»»æ„ä¸€ä¸ªå›è°ƒè§¦å‘ï¼ˆå› ä¸ºä¸çŸ¥é“ä¸¤ä¸ª future è°å…ˆå®Œæˆï¼‰ã€‚åœ¨ä¸åŒçš„å›è°ƒä¹‹é—´æ¶‰åŠå¤§é‡çš„æ•°æ®å…±äº«ï¼Œä¸€èˆ¬ç”¨ Arcï¼Œè¿™å°±æ¶‰åŠäº†å¤§é‡çš„å †å†…å­˜ç”³è¯·ã€‚            

æ­¤å¤–ï¼Œå½“ä¸€ä¸ªè¢«ç­‰å¾…çš„èµ„æºï¼ˆheterogeneous collectionsï¼‰åˆ°æ¥æ—¶ï¼Œéœ€è¦å°†å®ƒåˆ†é…åˆ°ä¸€ä¸ªå›è°ƒå‡½æ•°ä¸Šï¼Œæ­¤å¤„å¤§æ¦‚éœ€è¦åŠ¨æ€åˆ†å‘ã€‚ï¼ˆæˆ‘çš„ç†è§£æ˜¯ï¼Œcallback çš„å®ç°ä¸€èˆ¬æ˜¯æœ‰ä¸€ä¸ªâ€œå…¨å±€â€äº‹ä»¶ â†’ callback çš„è¡¨ã€‚ï¼‰
            
**Q2. What does a demand-driven future look like?**

- ä¸éœ€è¦åå¤åˆ†é…å†…å­˜ï¼šä¸ç”¨åœ¨ä¸åŒçš„ FnOnce ä¹‹é—´å…±äº«æ•°æ®ï¼ŒçŠ¶æ€æœºä»£ç å¯ä»¥è‡ªç„¶åœ°åˆ†äº«å˜é‡ï¼Œä¸”çŠ¶æ€æœºçš„å¤§å°åœ¨ç¼–è¯‘æœŸé—´å°±ç¡®å®šäº†ã€‚
- è¾ƒå°‘çš„åŠ¨æ€åˆ†å‘ï¼šè‡ªç„¶åœ°ç”±å­ future å»é©±åŠ¨ï¼ŒåŠ¨æ€åˆ†å‘åªå‘ç”Ÿåœ¨ `Waker::wake()` çš„è¿‡ç¨‹ä¸­ã€‚
  å­ future è¢« pollï¼Œè¿”å› `Poll::Ready`ï¼Œå›åˆ°çˆ¶ future çš„çŠ¶æ€æœºä¸­ï¼Œç»§ç»­è¿›è¡Œä¸‹ä¸€ä¸ªçŠ¶æ€ã€‚
- ä¸€ä¸ªå‰¯ä½œç”¨æ˜¯éœ€è¦ä¸€ä¸ªå¤–éƒ¨åŠ›é‡å» poll è¿™äº› future (Executor)ï¼Œè¿›è€Œåˆéœ€è¦ä¸€ä¸ªå¤–éƒ¨åŠ›é‡å»é€šçŸ¥ Executor (Reactor)ã€‚

#### Static dispatch V.S. dynamic dispatch:

- Static dispatch: åœ¨ç¼–è¯‘æœŸé—´ç¡®å®šå…·ä½“çš„ Future ç±»å‹ï¼Œæ²¡æœ‰è¿è¡Œæ—¶å¼€é”€ã€‚
- Dynamic dispatch: ä¸€èˆ¬çš„ç”¨é€”æ˜¯ heterogeneous collectionsã€‚
        
> You need to group together a number of objects which may have different underlying types but all implement the same trait. Trait objects must always be behind a pointer, which in practice usually requires heap allocation.


### Implementation details

- Futures that execute the futures:
  - â€œwaitâ€ï¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œfuture è¢«åˆ†é…åœ¨æ ˆä¸Šã€‚
  - â€œspawnâ€ï¼šä»çº¿ç¨‹æ± æŠ“ä¸€ä¸ªçº¿ç¨‹å»æ‰§è¡Œï¼Œfuture è¢«åˆ†é…åœ¨å †ä¸Šã€‚
- In a way, the task model is an instance of â€œgreenâ€ threading: we schedule a potentially large number of asynchronous tasks onto a much smaller number of real OS threads, and most of those tasks are blocked on some event most of the time.

### A little summary

State machines â†’ No heap allocation, no dynamic dispatching â†’ Zero-cost!
